{"version":3,"file":"static/js/353.a6bcfa2d.chunk.js","mappings":"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","sources":["components/Scene/shapes.js","components/Scene/Scene3D.jsx"],"sourcesContent":["import * as THREE from 'three';\nimport { MathUtils } from 'three';\n\nconst shapes = [\n  // Shape 1: \"Людинка\"\n  [\n    { position: new THREE.Vector3(0, 0.32, 0), rotation: new THREE.Euler(0, 0, 0) },\n    { position: new THREE.Vector3(0, 0, 0), rotation: new THREE.Euler(0, 0, 0) },\n    { position: new THREE.Vector3(-0.15, 0, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(-20)) },\n    { position: new THREE.Vector3(0.15, 0, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(20)) },\n    { position: new THREE.Vector3(-0.11, -0.4,0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(-15)) },\n    { position: new THREE.Vector3(0.11, -0.4, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(15)) }\n  ],\n  // // Shape 2 \"Сонце\"\n  // [\n  //   { position: new THREE.Vector3(0, 0, 0), rotation: new THREE.Euler(0, 0, 0) },\n  //   { position: new THREE.Vector3(0, 0.8, 0), rotation: new THREE.Euler(0, 0, 0) },\n  //   { position: new THREE.Vector3(0.8, 0.3, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(-70)) },\n  //   { position: new THREE.Vector3(-0.8, 0.3, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(70)) },\n  //   { position: new THREE.Vector3(0.5, -0.7, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(-330)) },\n  //   { position: new THREE.Vector3(-0.5, -0.7, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(330)) }\n  // ],\n  // // Shape 3: \"Собака\"\n  // [\n  //   { position: new THREE.Vector3(-0.4, 0.4, 0), rotation: new THREE.Euler(0, 0, 0) },\n  //   { position: new THREE.Vector3(0, 0, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(90)) },\n  //   { position: new THREE.Vector3(0.6, 0.3, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(-45)) },\n  //   { position: new THREE.Vector3(0.5, -0.5, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(15)) },\n  //   { position: new THREE.Vector3(-0.4, -0.5, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(-15)) },\n  //   { position: new THREE.Vector3(-0.55, 0.3, -0.3), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(90)) }\n  // ],\n  //   // Shape 3: \"Дім\"\n  //   [\n  //     { position: new THREE.Vector3(0, 0, 0), rotation: new THREE.Euler(0, 0, 0) },\n  //     { position: new THREE.Vector3(0, -0.5, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(90)) },\n  //     { position: new THREE.Vector3(-0.5, 0, 0), rotation: new THREE.Euler(0, 0, 0) },\n  //     { position: new THREE.Vector3(0.5, 0, 0), rotation: new THREE.Euler(0, 0, 0) },\n  //     { position: new THREE.Vector3(-0.3, 0.6, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(-45)) },\n  //     { position: new THREE.Vector3(0.3, 0.6, 0), rotation: new THREE.Euler(0, 0, MathUtils.degToRad(45)) }\n  //   ],\n];\n\nexport default shapes;","// Scene.js\nimport React, { useRef, useEffect, useImperativeHandle, forwardRef } from \"react\";\nimport * as THREE from \"three\";\nimport shapes from \"./shapes\";\nimport { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader\";\nimport { EffectComposer } from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport { RenderPass } from \"three/examples/jsm/postprocessing/RenderPass\";\nimport { SMAAPass } from \"three/examples/jsm/postprocessing/SMAAPass\";\nimport { OutputPass } from \"three/examples/jsm/postprocessing/OutputPass\";\nimport { OBB } from \"three/examples/jsm/math/OBB.js\";\n\n/*======================================\n   CONFIGURATION\n======================================*/\nconst config = {\n  debug: {\n    enable: false, // Головний перемикач дебаг-режиму. Якщо false – всі дебаг-ефекти вимкнені.\n    showDebugCursorCollision: false,\n    debugCursorColor: 0xff00ff,\n    showDebugOBB: false,\n    showDebugSphere: false,\n  },\n  boundary: {\n    collisionType: \"OBB\", // 'OBB' або 'sphere'\n    sphereScale: 1,\n  },\n  speed: {\n    objectSpeedMultiplier: 1, // Множник для швидкостей об’єктів\n    stateLerpSpeed: 1, // Швидкість переходу при анімації стану\n  },\n  performance: {\n    enablePostProcessing: false, // Вмикає/вимикає постпроцесінг\n    pixelRatio: 1, // Нижчий pixelRatio для зниження навантаження на GPU\n    enableShadows: false, // Вмикає/вимикає тіні\n    antialias: true, // Антіаліас може бути вимкнено для покращення продуктивності\n  },\n  constants: {\n    CURSOR_IMPULSE_MULTIPLIER: 0.05, // Регулювання сили відштовхування курсора\n  },\n  controls: {\n    enableScrollRotation: false, // Початкове значення для повороту сцени при скролі\n    toggleKey: \"r\", // Клавіша для перемикання повороту сцени\n    enableScrollImpulse: false, // Початкове значення для імпульсу при скролі\n    toggleImpulseKey: \"i\", // Клавіша для перемикання імпульсу при скролі\n  },\n  camera: {\n    fov: 20, // Налаштування FOV для камери\n  },\n};\n\n/*======================================\n   HELPER FUNCTIONS\n======================================*/\n// Створення OBB для mesh\nfunction createOBB(mesh) {\n  mesh.updateWorldMatrix(true, false);\n  mesh.geometry.computeBoundingBox();\n  const bbox = mesh.geometry.boundingBox;\n  const size = new THREE.Vector3();\n  bbox.getSize(size);\n  const halfSize = size.multiplyScalar(0.5);\n  const center = new THREE.Vector3();\n  bbox.getCenter(center);\n  center.applyMatrix4(mesh.matrixWorld);\n  const obb = new OBB();\n  obb.center.copy(center);\n  obb.halfSize.copy(halfSize);\n  const m3 = new THREE.Matrix3().setFromMatrix4(mesh.matrixWorld);\n  obb.rotation.copy(m3);\n  return obb;\n}\n\n// Створення OBB-хелпера для візуалізації\nfunction createOBBHelper(obb) {\n  const vertices = [];\n  for (let i = 0; i < 8; i++) {\n    const sx = i & 1 ? 1 : -1;\n    const sy = i & 2 ? 1 : -1;\n    const sz = i & 4 ? 1 : -1;\n    const localCorner = new THREE.Vector3(\n      sx * obb.halfSize.x,\n      sy * obb.halfSize.y,\n      sz * obb.halfSize.z\n    );\n    localCorner.applyMatrix3(obb.rotation);\n    localCorner.add(obb.center);\n    vertices.push(localCorner);\n  }\n  const indices = [0, 1, 0, 2, 0, 4, 1, 3, 1, 5, 2, 3, 2, 6, 3, 7, 4, 5, 4, 6, 5, 7, 6, 7];\n  const geometry = new THREE.BufferGeometry();\n  const positions = new Float32Array(indices.length * 3);\n  for (let i = 0; i < indices.length; i++) {\n    const v = vertices[indices[i]];\n    positions[i * 3] = v.x;\n    positions[i * 3 + 1] = v.y;\n    positions[i * 3 + 2] = v.z;\n  }\n  geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n  const material = new THREE.LineBasicMaterial({\n    color: 0x00ff00,\n    depthTest: false,\n    transparent: true,\n    opacity: 1,\n  });\n  return new THREE.LineSegments(geometry, material);\n}\n\n// Обчислення розмірів фрустума камери\nfunction computeFrustumDimensions(camera) {\n  const frustumHeight =\n    2 * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2)) * Math.abs(camera.position.z);\n  const frustumWidth = frustumHeight * camera.aspect;\n  return { frustumWidth, frustumHeight };\n}\n\n/*======================================\n   COMPONENT: Scene\n======================================*/\nconst Scene = forwardRef(({ hdrTexture, showDebugButtons }, ref) => {\n  // ===== References & State =====\n  const mountRef = useRef(null);\n  const composerRef = useRef(null);\n  const dynamicObjectsRef = useRef([]);\n  const oldVelocitiesRef = useRef([]);\n  const oldRotationSpeedsRef = useRef([]);\n  const oldMassesRef = useRef([]);\n  const collisionsEnabledRef = useRef(true);\n  const sceneRef = useRef(null);\n  const cameraRef = useRef(null);\n  const rendererRef = useRef(null);\n  const objectsGroupRef = useRef(new THREE.Group());\n  const customStatesRef = useRef(shapes);\n  const currentStateIndexRef = useRef(0);\n  const mouseCoordsRef = useRef(new THREE.Vector2());\n  const hasMouseMovedRef = useRef(false);\n  const cursorCollisionDebugRef = useRef(null);\n  const scrollRotationEnabledRef = useRef(config.controls.enableScrollRotation);\n  const scrollImpulseEnabledRef = useRef(config.controls.enableScrollImpulse);\n  const cursorCollisionDisabledRef = useRef(false);\n  const lastClickPointRef = useRef(new THREE.Vector3());\n\n  // ===== Ініціалізація сцени та рендеринг =====\n  useEffect(() => {\n    // Обробка клавіш для перемикання функціональностей\n    function onKeyDown(event) {\n      const key = event.key.toLowerCase();\n      if (key === config.controls.toggleKey.toLowerCase()) {\n        scrollRotationEnabledRef.current = !scrollRotationEnabledRef.current;\n        console.log(\"Scroll rotation toggled:\", scrollRotationEnabledRef.current);\n      }\n      if (key === config.controls.toggleImpulseKey.toLowerCase()) {\n        scrollImpulseEnabledRef.current = !scrollImpulseEnabledRef.current;\n        console.log(\"Scroll impulse toggled:\", scrollImpulseEnabledRef.current);\n      }\n    }\n    window.addEventListener(\"keydown\", onKeyDown);\n\n    // Ініціалізація сцени\n    const scene = new THREE.Scene();\n    sceneRef.current = scene;\n    const objectsGroup = new THREE.Group();\n    objectsGroupRef.current = objectsGroup;\n    scene.add(objectsGroup);\n\n    // Дебаг: створення об’єкта для колізій з курсором\n    if (config.debug.enable && config.debug.showDebugCursorCollision) {\n      const debugSphere = new THREE.Mesh(\n        new THREE.SphereGeometry(0.05, 8, 8),\n        new THREE.MeshBasicMaterial({\n          color: config.debug.debugCursorColor,\n          wireframe: true,\n        })\n      );\n      debugSphere.visible = false;\n      scene.add(debugSphere);\n      cursorCollisionDebugRef.current = debugSphere;\n    }\n\n    // Налаштування камери\n    const camera = new THREE.PerspectiveCamera(\n      config.camera.fov,\n      mountRef.current.clientWidth / mountRef.current.clientHeight,\n      0.1,\n      1000\n    );\n    camera.position.z = 5;\n    cameraRef.current = camera;\n\n    // Обчислення boundary за розмірами фрустума\n    const { frustumWidth, frustumHeight } = computeFrustumDimensions(camera);\n    const collisionDepth = 1;\n    const boundary = {\n      halfWidth: frustumWidth / 2,\n      halfHeight: frustumHeight / 2,\n      halfDepth: collisionDepth / 2,\n    };\n\n    // Дебаг: візуалізація boundary (опціонально)\n    if (config.debug.enable && config.debug.showDebugSphere) {\n      const boundaryCube = new THREE.Mesh(\n        new THREE.BoxGeometry(\n          boundary.halfWidth * 2,\n          boundary.halfHeight * 2,\n          boundary.halfDepth * 2\n        ),\n        new THREE.MeshBasicMaterial({\n          color: 0xff0000,\n          wireframe: false,\n          transparent: true,\n          opacity: 0.2,\n        })\n      );\n      boundaryCube.position.set(0, 0, 0);\n      scene.add(boundaryCube);\n    }\n\n    // Налаштування рендерера\n    const renderer = new THREE.WebGLRenderer({\n      antialias: config.performance.antialias,\n      alpha: true,\n      premultipliedAlpha: false,\n    });\n    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n    renderer.setPixelRatio(config.performance.pixelRatio);\n    renderer.shadowMap.enabled = config.performance.enableShadows;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.0;\n    mountRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Налаштування постпроцесінгу\n    let composer;\n    if (config.performance.enablePostProcessing) {\n      composer = new EffectComposer(renderer);\n      composerRef.current = composer;\n      const renderPass = new RenderPass(scene, camera);\n      composer.addPass(renderPass);\n      if (renderer.getPixelRatio() === 1) {\n        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);\n        composer.addPass(smaaPass);\n      }\n      const outputPass = new OutputPass();\n      composer.addPass(outputPass);\n    }\n\n    // Обробка HDR текстури\n    renderer.physicallyCorrectLights = true;\n    const pmremGenerator = new THREE.PMREMGenerator(renderer);\n    pmremGenerator.compileEquirectangularShader();\n    if (hdrTexture) {\n      const envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;\n      scene.environment = envMap;\n      pmremGenerator.dispose();\n    } else {\n      new RGBELoader()\n        .setPath(\"hdr_maps/\")\n        .load(\"poly_haven_studio_1k.hdr\", (texture) => {\n          const envMap = pmremGenerator.fromEquirectangular(texture).texture;\n          scene.environment = envMap;\n          texture.dispose();\n          pmremGenerator.dispose();\n        });\n    }\n\n    // Налаштування освітлення\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);\n    directionalLight.position.set(2, 2, 2);\n    directionalLight.castShadow = config.performance.enableShadows;\n    directionalLight.shadow.mapSize.width = 2048;\n    directionalLight.shadow.mapSize.height = 2048;\n    directionalLight.shadow.camera.near = 0.1;\n    directionalLight.shadow.camera.far = 20;\n    directionalLight.shadow.camera.left = -5;\n    directionalLight.shadow.camera.right = 5;\n    directionalLight.shadow.camera.top = 5;\n    directionalLight.shadow.camera.bottom = -5;\n    scene.add(directionalLight);\n\n    /*--------------------------------------\n       Функція створення об’єктів\n    --------------------------------------*/\n    const dynamicObjects = [];\n    dynamicObjectsRef.current = dynamicObjects;\n    function createObj({ geometry, color, x, y, speed = 0.05, rotation, isStatic = false }) {\n      geometry.computeBoundingSphere();\n      const material = new THREE.MeshPhysicalMaterial({\n        color,\n        metalness: 0.5,\n        roughness: 0.3,\n        clearcoat: 1.0,\n        clearcoatRoughness: 0.1,\n        sheen: 0.5,\n        transmission: 0.2,\n        opacity: 1,\n        transparent: true,\n      });\n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.castShadow = config.performance.enableShadows;\n      mesh.receiveShadow = config.performance.enableShadows;\n\n      if (!isStatic) {\n        mesh.rotationSpeed = new THREE.Vector3(\n          (Math.random() - 0.5) * speed * config.speed.objectSpeedMultiplier,\n          (Math.random() - 0.5) * speed * config.speed.objectSpeedMultiplier,\n          (Math.random() - 0.5) * speed * config.speed.objectSpeedMultiplier\n        );\n        mesh.velocity = new THREE.Vector3(\n          (Math.random() - 0.5) * speed * config.speed.objectSpeedMultiplier,\n          (Math.random() - 0.5) * speed * config.speed.objectSpeedMultiplier,\n          (Math.random() - 0.5) * speed * config.speed.objectSpeedMultiplier\n        );\n      } else {\n        mesh.rotationSpeed = new THREE.Vector3(0, 0, 0);\n        mesh.velocity = new THREE.Vector3(0, 0, 0);\n      }\n\n      mesh.initialVelocity = mesh.velocity.clone();\n      mesh.initialRotationSpeed = mesh.rotationSpeed.clone();\n      mesh.mass = 1;\n      mesh.position.set(x, y, 0);\n      mesh.boundingRadius = geometry.boundingSphere.radius * config.boundary.sphereScale;\n      mesh.isLerpingToState = false;\n      mesh.lerpAlpha = 0;\n      mesh.startPos = new THREE.Vector3();\n      mesh.targetPos = new THREE.Vector3();\n      mesh.startRot = new THREE.Euler();\n      mesh.targetRot = new THREE.Euler();\n\n      if (rotation) {\n        mesh.rotation.copy(rotation);\n      }\n\n      // Дебаг: створення OBB-хелпера для CapsuleGeometry\n      if (\n        config.boundary.collisionType === \"OBB\" &&\n        geometry.type === \"CapsuleGeometry\" &&\n        config.debug.enable &&\n        config.debug.showDebugOBB\n      ) {\n        mesh.obbHelper = createOBBHelper(createOBB(mesh));\n        scene.add(mesh.obbHelper);\n      }\n\n      objectsGroup.add(mesh);\n      dynamicObjectsRef.current.push(mesh);\n    }\n\n    // Створення об’єктів: центральна сфера та декілька Capsule\n    const maxRange = 10;\n    createObj({\n      geometry: new THREE.SphereGeometry(0.1, 50, 50),\n      color: 0x000000,\n      x: (Math.random() - 0.5) * maxRange,\n      y: (Math.random() - 0.5) * maxRange,\n      isStatic: false,\n    });\n    const count = 5;\n    for (let i = 0; i < count; i++) {\n      createObj({\n        geometry: new THREE.CapsuleGeometry(0.03, 0.35, 50, 50),\n        color: 0x000000,\n        x: (Math.random() - 0.5) * maxRange,\n        y: (Math.random() - 0.5) * maxRange,\n      });\n    }\n\n    /*--------------------------------------\n       Обробка подій скролу\n    --------------------------------------*/\n    const scrollFactor = 0.001;\n    let prevScrollY = window.scrollY;\n    const scrollImpulseFactor = -0.0002;\n    function throttle(fn, delay) {\n      let lastCall = 0;\n      return function (...args) {\n        const now = Date.now();\n        if (now - lastCall < delay) return;\n        lastCall = now;\n        return fn(...args);\n      };\n    }\n    function handleScroll() {\n      const scrollY = window.scrollY;\n      const delta = scrollY - prevScrollY;\n      prevScrollY = scrollY;\n      if (scrollRotationEnabledRef.current && objectsGroupRef.current) {\n        objectsGroupRef.current.rotation.y = scrollY * scrollFactor;\n      }\n      if (scrollImpulseEnabledRef.current) {\n        dynamicObjectsRef.current.forEach((obj) => {\n          obj.velocity.y += -delta * scrollImpulseFactor;\n        });\n      }\n    }\n    const throttledScrollHandler = throttle(handleScroll, 16);\n    window.addEventListener(\"scroll\", throttledScrollHandler);\n\n    /*--------------------------------------\n       Обробка руху миші\n    --------------------------------------*/\n    function onMouseMove(event) {\n      const rect = mountRef.current.getBoundingClientRect();\n      const mouse = new THREE.Vector2(\n        ((event.clientX - rect.left) / rect.width) * 2 - 1,\n        -((event.clientY - rect.top) / rect.height) * 2 + 1\n      );\n      mouseCoordsRef.current.copy(mouse);\n      hasMouseMovedRef.current = true;\n    }\n    window.addEventListener(\"mousemove\", onMouseMove);\n\n    /*--------------------------------------\n       Анімаційний цикл\n    --------------------------------------*/\n    const clock = new THREE.Clock();\n    function animate() {\n      requestAnimationFrame(animate);\n      const delta = clock.getDelta();\n\n      // Обнулення лічильника колізій\n      dynamicObjectsRef.current.forEach((obj) => {\n        obj.collisionCount = 0;\n      });\n\n      // Оновлення позицій та анімація переходу станів\n      dynamicObjectsRef.current.forEach((obj) => {\n        if (obj.isLerpingToState) {\n          obj.lerpAlpha += delta * config.speed.stateLerpSpeed;\n          const t = Math.min(obj.lerpAlpha, 1);\n          obj.position.lerpVectors(obj.startPos, obj.targetPos, t);\n          const qa = new THREE.Quaternion().setFromEuler(obj.startRot);\n          const qb = new THREE.Quaternion().setFromEuler(obj.targetRot);\n          const qm = new THREE.Quaternion().slerpQuaternions(qa, qb, t);\n          obj.rotation.setFromQuaternion(qm);\n          if (t >= 1) obj.isLerpingToState = false;\n        } else {\n          obj.rotation.x += obj.rotationSpeed.x * delta;\n          obj.rotation.z += obj.rotationSpeed.z * delta;\n          obj.position.x += obj.velocity.x * delta;\n          obj.position.y += obj.velocity.y * delta;\n          obj.position.z += obj.velocity.z * delta;\n        }\n\n        // Перевірка колізій з boundary\n        const r = obj.boundingRadius || 0;\n        if (obj.position.x + r > boundary.halfWidth) {\n          obj.position.x = boundary.halfWidth - r;\n          obj.velocity.x *= -1;\n        }\n        if (obj.position.x - r < -boundary.halfWidth) {\n          obj.position.x = -boundary.halfWidth + r;\n          obj.velocity.x *= -1;\n        }\n        if (obj.position.y + r > boundary.halfHeight) {\n          obj.position.y = boundary.halfHeight - r;\n          obj.velocity.y *= -1;\n        }\n        if (obj.position.y - r < -boundary.halfHeight) {\n          obj.position.y = -boundary.halfHeight + r;\n          obj.velocity.y *= -1;\n        }\n        if (obj.position.z + r > boundary.halfDepth) {\n          obj.position.z = boundary.halfDepth - r;\n          obj.velocity.z *= -1;\n        }\n        if (obj.position.z - r < -boundary.halfDepth) {\n          obj.position.z = -boundary.halfDepth + r;\n          obj.velocity.z *= -1;\n        }\n\n        // Оновлення OBB-хелпера для дебагу\n        if (obj.obbHelper && config.debug.enable && config.debug.showDebugOBB) {\n          const obb = createOBB(obj);\n          const newHelper = createOBBHelper(obb);\n          obj.obbHelper.geometry.dispose();\n          obj.obbHelper.geometry = newHelper.geometry;\n        }\n      });\n\n      // Обробка колізій з курсором\n      if (hasMouseMovedRef.current && !cursorCollisionDisabledRef.current) {\n        const raycaster = new THREE.Raycaster();\n        raycaster.setFromCamera(mouseCoordsRef.current, cameraRef.current);\n        const ray = raycaster.ray;\n        let cursorCollisionFound = false;\n        dynamicObjectsRef.current.forEach((obj) => {\n          const sphere = new THREE.Sphere(obj.position, obj.boundingRadius);\n          if (ray.intersectsSphere(sphere)) {\n            const closestPoint = new THREE.Vector3();\n            ray.closestPointToPoint(obj.position, closestPoint);\n            const dist = closestPoint.distanceTo(obj.position);\n            if (dist < obj.boundingRadius) {\n              const n = new THREE.Vector3().subVectors(obj.position, closestPoint).normalize();\n              const impulseStrength = config.constants.CURSOR_IMPULSE_MULTIPLIER;\n              obj.velocity.add(n.clone().multiplyScalar(impulseStrength));\n              const rotationalImpulse = new THREE.Vector3(n.y, 0, -n.x).multiplyScalar(impulseStrength * 0.5);\n              obj.rotationSpeed.add(rotationalImpulse);\n              obj.collisionCount = (obj.collisionCount || 0) + 1;\n              if (config.debug.enable && config.debug.showDebugCursorCollision && cursorCollisionDebugRef.current) {\n                cursorCollisionDebugRef.current.position.copy(closestPoint);\n                cursorCollisionDebugRef.current.visible = true;\n              }\n              cursorCollisionFound = true;\n            }\n          }\n        });\n        if (cursorCollisionDebugRef.current && !cursorCollisionFound) {\n          cursorCollisionDebugRef.current.visible = false;\n        }\n      }\n\n      // Перевірка колізій між об'єктами (виконується лише, якщо collisionsEnabledRef.current === true)\n      if (collisionsEnabledRef.current) {\n        for (let i = 0; i < dynamicObjectsRef.current.length; i++) {\n          const objA = dynamicObjectsRef.current[i];\n          for (let j = i + 1; j < dynamicObjectsRef.current.length; j++) {\n            const objB = dynamicObjectsRef.current[j];\n            let collisionDetected = false;\n\n            if (config.boundary.collisionType === \"OBB\") {\n              const obbA = createOBB(objA);\n              const obbB = createOBB(objB);\n              collisionDetected = obbA.intersectsOBB(obbB);\n            } else if (config.boundary.collisionType === \"sphere\") {\n              const distance = objA.position.distanceTo(objB.position);\n              const radiusSum = objA.boundingRadius + objB.boundingRadius;\n              collisionDetected = distance < radiusSum;\n            }\n\n            if (collisionDetected) {\n              const normal = new THREE.Vector3().subVectors(objA.position, objB.position).normalize();\n              const impulseStrength = 0.1;\n              const impulse = normal.clone().multiplyScalar(impulseStrength);\n              objA.velocity.add(impulse);\n              objB.velocity.sub(impulse);\n              objA.collisionCount = (objA.collisionCount || 0) + 1;\n              objB.collisionCount = (objB.collisionCount || 0) + 1;\n            }\n          }\n        }\n      }\n\n      // Демпфінг швидкостей та обертання\n      dynamicObjectsRef.current.forEach((obj) => {\n        const baseDamping = 0.99;\n        const extraDamping = 1 - Math.min(0.05 * (obj.collisionCount || 0), 0.5);\n        const dampingFactor = baseDamping * extraDamping;\n        const currentSpeed = obj.velocity.length();\n        const dampedSpeed = currentSpeed * dampingFactor;\n        const minSpeed = obj.initialVelocity ? obj.initialVelocity.length() : 0;\n        const finalSpeed = Math.max(dampedSpeed, minSpeed);\n        if (obj.velocity.length() > 0) {\n          obj.velocity.setLength(finalSpeed);\n        }\n        const currentRotSpeed = obj.rotationSpeed.length();\n        const dampedRotSpeed = currentRotSpeed * dampingFactor;\n        const minRotSpeed = obj.initialRotationSpeed ? obj.initialRotationSpeed.length() : 0;\n        const finalRotSpeed = Math.max(dampedRotSpeed, minRotSpeed);\n        if (obj.rotationSpeed.length() > 0) {\n          obj.rotationSpeed.setLength(finalRotSpeed);\n        }\n      });\n\n      // Рендеринг: постпроцесінг або прямий рендер\n      if (config.performance.enablePostProcessing && composerRef.current) {\n        composerRef.current.render(delta);\n      } else {\n        renderer.render(scene, camera);\n      }\n    }\n    animate();\n\n    // Обробка зміни розміру вікна\n    function onWindowResize() {\n      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n      const { frustumWidth, frustumHeight } = computeFrustumDimensions(camera);\n      boundary.halfWidth = frustumWidth / 2;\n      boundary.halfHeight = frustumHeight / 2;\n    }\n    window.addEventListener(\"resize\", onWindowResize);\n\n    // Cleanup\n    return () => {\n      window.removeEventListener(\"resize\", onWindowResize);\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"scroll\", throttledScrollHandler);\n      window.removeEventListener(\"keydown\", onKeyDown);\n      mountRef.current.removeChild(renderer.domElement);\n      renderer.dispose();\n    };\n  }, [hdrTexture]);\n\n  /*======================================\n     Методи керування об’єктами\n  ======================================*/\n  function stopObjects() {\n    const objects = dynamicObjectsRef.current;\n    if (!objects || !objects.length) return;\n    oldVelocitiesRef.current = objects.map((o) => o.velocity.clone());\n    oldRotationSpeedsRef.current = objects.map((o) => o.rotationSpeed.clone());\n    oldMassesRef.current = objects.map((o) => o.mass);\n    objects.forEach((o) => {\n      o.mass = 0;\n      o.velocity.set(0, 0, 0);\n      o.rotationSpeed.set(0, 0, 0);\n    });\n  }\n\n  function continueObjects() {\n    const objects = dynamicObjectsRef.current;\n    if (!objects || !objects.length) return;\n    // Якщо продовження викликається з події mouseup з \"збиранням\",\n    // collisionsEnabledRef вже встановлено в false, тому тут ми знову відновлюємо колізії через 500 мс.\n    collisionsEnabledRef.current = false;\n    setTimeout(() => {\n      collisionsEnabledRef.current = true;\n    }, 500);\n\n    const explosionCenter = lastClickPointRef.current || new THREE.Vector3(0, 0, 0);\n    const explosionStrength = 1;\n    objects.forEach((o) => {\n      o.mass = 1;\n      let direction = o.position.clone().sub(explosionCenter);\n      let distance = direction.length();\n      if (distance < 0.001) {\n        direction = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n        distance = direction.length();\n      }\n      direction.normalize();\n      let impulseMagnitude = explosionStrength / (distance + 0.5);\n      impulseMagnitude *= 0.8 + Math.random() * 0.4;\n      o.velocity.copy(direction.multiplyScalar(impulseMagnitude));\n      const explosionRotSpeed = 0.1 + Math.random() * 0.3;\n      o.rotationSpeed.set(\n        (Math.random() - 0.5) * explosionRotSpeed,\n        (Math.random() - 0.5) * explosionRotSpeed,\n        (Math.random() - 0.5) * explosionRotSpeed\n      );\n      o.rotation.set(\n        Math.random() * Math.PI * 2,\n        Math.random() * Math.PI * 2,\n        Math.random() * Math.PI * 2\n      );\n    });\n  }\n\n  function showNextState() {\n    const objects = dynamicObjectsRef.current;\n    if (!objects?.length) return;\n    currentStateIndexRef.current++;\n    if (currentStateIndexRef.current >= customStatesRef.current.length) {\n      currentStateIndexRef.current = 0;\n    }\n    console.log(\"Застосовується фігура, state index:\", currentStateIndexRef.current);\n    applyCurrentState();\n  }\n\n  function showPreviousState() {\n    const objects = dynamicObjectsRef.current;\n    if (!objects?.length) return;\n    currentStateIndexRef.current--;\n    if (currentStateIndexRef.current < 0) {\n      currentStateIndexRef.current = customStatesRef.current.length - 1;\n    }\n    applyCurrentState();\n  }\n\n  function applyCurrentState() {\n    const objects = dynamicObjectsRef.current;\n    const stateIndex = currentStateIndexRef.current;\n    const states = customStatesRef.current;\n    if (!states[stateIndex]) return;\n    states[stateIndex].forEach((transform, i) => {\n      const { position, rotation } = transform;\n      const obj = objects[i];\n      obj.startPos = obj.position.clone();\n      obj.startRot = new THREE.Euler().copy(obj.rotation);\n      obj.targetPos = position.clone();\n      obj.targetRot = new THREE.Euler(rotation.x, rotation.y, rotation.z);\n      obj.lerpAlpha = 0;\n      obj.isLerpingToState = true;\n    });\n  }\n\n  /*======================================\n     Обробка подій mousedown / mouseup\n  ======================================*/\n  useEffect(() => {\n    let isMouseDown = false;\n    let isGathering = false;\n    let gatherTimeout = null;\n\n    function handleMouseDown(event) {\n      isMouseDown = true;\n      collisionsEnabledRef.current = false;\n      \n      const rect = mountRef.current.getBoundingClientRect();\n      const mouse = new THREE.Vector2(\n        ((event.clientX - rect.left) / rect.width) * 2 - 1,\n        -((event.clientY - rect.top) / rect.height) * 2 + 1\n      );\n      const raycaster = new THREE.Raycaster();\n      raycaster.setFromCamera(mouse, cameraRef.current);\n      const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);\n      const clickPoint = new THREE.Vector3();\n      raycaster.ray.intersectPlane(planeZ, clickPoint);\n      lastClickPointRef.current = clickPoint.clone();\n      cursorCollisionDisabledRef.current = true;\n\n      gatherTimeout = setTimeout(() => {\n        if (isMouseDown) {\n          isGathering = true;\n          const state =\n            customStatesRef.current[\n              Math.floor(Math.random() * customStatesRef.current.length)\n            ];\n          state.forEach((transform, i) => {\n            const obj = dynamicObjectsRef.current[i];\n            if (!obj) return;\n            obj.startPos = obj.position.clone();\n            obj.startRot = new THREE.Euler().copy(obj.rotation);\n            obj.targetPos = transform.position.clone().add(lastClickPointRef.current);\n            obj.targetRot = new THREE.Euler(transform.rotation.x, transform.rotation.y, transform.rotation.z);\n            obj.lerpAlpha = 0;\n            obj.isLerpingToState = true;\n          });\n          stopObjects();\n        }\n      }, 500);\n    }\n\n    function handleMouseUp() {\n      if (!isMouseDown) return;\n      isMouseDown = false;\n      if (gatherTimeout) {\n        clearTimeout(gatherTimeout);\n        gatherTimeout = null;\n      }\n      if (isGathering) {\n        continueObjects();\n        isGathering = false;\n      } else {\n        setTimeout(() => {\n          collisionsEnabledRef.current = true;\n        }, 1000);\n      }\n      setTimeout(() => {\n        cursorCollisionDisabledRef.current = false;\n      }, 1000);\n    }\n\n    window.addEventListener(\"mousedown\", handleMouseDown);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n    return () => {\n      window.removeEventListener(\"mousedown\", handleMouseDown);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, []);\n\n  /*======================================\n     Надання методів через ref\n  ======================================*/\n  useImperativeHandle(ref, () => ({\n    stopObjects,\n    continueObjects,\n    showNextState,\n    showPreviousState,\n  }));\n\n  // ===== Render компонента =====\n  return (\n    <div\n      ref={mountRef}\n      style={{\n        position: \"fixed\",\n        top: 0,\n        left: 0,\n        width: \"100vw\",\n        height: \"100vh\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n      }}\n    />\n  );\n});\n\nexport default Scene;"],"names":["position","THREE","rotation","MathUtils","degToRad","config","debug","enable","showDebugCursorCollision","debugCursorColor","showDebugOBB","showDebugSphere","boundary","collisionType","sphereScale","speed","objectSpeedMultiplier","stateLerpSpeed","performance","enablePostProcessing","pixelRatio","enableShadows","antialias","constants","CURSOR_IMPULSE_MULTIPLIER","controls","enableScrollRotation","toggleKey","enableScrollImpulse","toggleImpulseKey","camera","fov","createOBB","mesh","updateWorldMatrix","geometry","computeBoundingBox","bbox","boundingBox","size","getSize","halfSize","multiplyScalar","center","getCenter","applyMatrix4","matrixWorld","obb","OBB","copy","m3","setFromMatrix4","createOBBHelper","vertices","i","sx","sy","sz","localCorner","x","y","z","applyMatrix3","add","push","indices","positions","Float32Array","length","v","setAttribute","material","color","depthTest","transparent","opacity","computeFrustumDimensions","frustumHeight","Math","tan","abs","frustumWidth","aspect","forwardRef","_ref","ref","hdrTexture","showDebugButtons","mountRef","useRef","composerRef","dynamicObjectsRef","oldVelocitiesRef","oldRotationSpeedsRef","oldMassesRef","collisionsEnabledRef","sceneRef","cameraRef","rendererRef","objectsGroupRef","customStatesRef","shapes","currentStateIndexRef","mouseCoordsRef","hasMouseMovedRef","cursorCollisionDebugRef","scrollRotationEnabledRef","scrollImpulseEnabledRef","cursorCollisionDisabledRef","lastClickPointRef","stopObjects","objects","current","map","o","velocity","clone","rotationSpeed","mass","forEach","set","continueObjects","setTimeout","explosionCenter","direction","sub","distance","random","normalize","impulseMagnitude","explosionRotSpeed","PI","showNextState","console","log","applyCurrentState","showPreviousState","stateIndex","states","transform","obj","startPos","startRot","targetPos","targetRot","lerpAlpha","isLerpingToState","useEffect","onKeyDown","event","key","toLowerCase","window","addEventListener","scene","objectsGroup","debugSphere","wireframe","visible","clientWidth","clientHeight","halfWidth","halfHeight","halfDepth","collisionDepth","boundaryCube","renderer","alpha","premultipliedAlpha","composer","setSize","setPixelRatio","shadowMap","enabled","type","toneMapping","toneMappingExposure","appendChild","domElement","EffectComposer","renderPass","RenderPass","addPass","getPixelRatio","smaaPass","SMAAPass","innerWidth","innerHeight","outputPass","OutputPass","physicallyCorrectLights","pmremGenerator","compileEquirectangularShader","envMap","fromEquirectangular","texture","environment","dispose","RGBELoader","setPath","load","ambientLight","directionalLight","castShadow","shadow","mapSize","width","height","near","far","left","right","top","bottom","createObj","_ref2","isStatic","computeBoundingSphere","metalness","roughness","clearcoat","clearcoatRoughness","sheen","transmission","receiveShadow","initialVelocity","initialRotationSpeed","boundingRadius","boundingSphere","radius","obbHelper","prevScrollY","scrollY","throttledScrollHandler","fn","delay","lastCall","now","Date","arguments","throttle","delta","onMouseMove","rect","getBoundingClientRect","mouse","clientX","clientY","clock","onWindowResize","updateProjectionMatrix","animate","requestAnimationFrame","getDelta","collisionCount","t","min","lerpVectors","qa","setFromEuler","qb","qm","slerpQuaternions","setFromQuaternion","r","newHelper","raycaster","setFromCamera","ray","cursorCollisionFound","sphere","intersectsSphere","closestPoint","closestPointToPoint","distanceTo","n","subVectors","impulseStrength","rotationalImpulse","objA","j","objB","collisionDetected","obbA","obbB","intersectsOBB","impulse","dampingFactor","dampedSpeed","minSpeed","finalSpeed","max","setLength","dampedRotSpeed","minRotSpeed","finalRotSpeed","render","removeEventListener","removeChild","isMouseDown","isGathering","gatherTimeout","handleMouseDown","planeZ","clickPoint","intersectPlane","floor","handleMouseUp","clearTimeout","useImperativeHandle","_jsx","style","overflow","pointerEvents"],"sourceRoot":""}